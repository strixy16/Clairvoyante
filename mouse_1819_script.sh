# Commands run for CISC874 mouse project

#### RUNNING CLAIRVOYANTE #####

# Get chromosomes 18-19 out of reference genome file
samtools faidx mouse_data/GRCm38_68.fa -r select_chr -o mouse_data/GRCm38_68.18-19.fa

# Clairvoyante can only call variants on one sample at a time
# This command generates commands for calling variants on a 10000bp segment of the chromosomes found in both the reference and bam file
# chjpnt_fn is the pretrained human model
# ref_fn is the reference FASTA file
# bam_fn is the read set BAM file
# includingAllContigs is a boolean indicating to generate commands for all of the chr found in ref and bam
# sampleName is the sample name used in the FASTA and BAM files
# output_prefix is the prefix that will be included for every output VCF from the model
python clairvoyante/callVarBamParallel.py \
      --chkpnt_fn trainedModels/fullv3-illumina-novoalign-hg001-hg38/learningRate1e-3.epoch999 \
      --ref_fn mouse_data/GRCm38_68.18-19.fa \
      --bam_fn mouse_data/129S1_SvImJ.bam \
      --includingAllContigs \
      --tensorflowThreads 4 \
      --sampleName 129S1_SvImJ \
      --output_prefix mg001 \
      > mouse_1819/mouse18-19_commands.sh

# makes GPUs invisible to Clairvoyante so it will use CPU only
export CUDA_VISIBLE_DEVICES=""

# Navigate to directory that commands file was put
cd mouse_1819

# Run the commands in parallel
cat mouse18-19_commands.sh | parallel -j4

# Concatenate and sort all of the vcf files generated by Clairvoyante
vcfcat mg001*.vcf | vcfstreamsort > mg001.18-19.vcf

# First sort doesn't entirely work, sort it again with bcftools
bcftools sort mg001.18-19.vcf > mg001.18-19.sorted.vcf

# Compress the sorted file for metric calculations
bgzip -c mg001.18-19.sorted.vcf.gz
# Generate index for the sorted VCF file
tabix mg001.18-19.sorted.vcf.gz

#### METRIC CALCULATIONS ####

# Navigate back to main Clairvoyante file
cd ../mouse_data/

# Setting up files for use by rtg vcfeval

# Generate structured data file for reference genome (needed for rtg vcfeval step)
rtg format -o SDF GRCm38_68.18-19.fa

# Preprocessing commands from Luo et al.
### INDELS ###
# Preprocessing baseline VCF file
gzip -dc 129S1_SvImJ.indels.vcf.gz | vcfbreakmulti | bgziptabix 129S1_SvImJ.indels.breakmulti.vcf.gz

# Remove insertions and deletions >4bp from baseline
gzip -dc 129S1_SvImJ.indels.breakmulti.vcf.gz | perl -ane 'if(/^#/){print}else{if(length($F[3])==1 && length($F[4])==1){print}elsif(length($F[3])==1 && length($F[4])<=5){print}elsif(length($F[3])<=5 && length($F[4])==1){print}}' | bgziptabix 129S1_SvImJ.indels.breakmulti.withOutSV.vcf.gz

# Retain only one record for heterozygous alternative
gzip -dc 129S1_SvImJ.indels.breakmulti.withOutSV.vcf.gz | perl -ane 'BEGIN{%a=();}{if(/^#/){print}elsif(not defined $a{"$F[0]-$F[1]"}){print;$a{"$F[0]-$F[1]"}=1;}}' | bgziptabix 129S1_SvImJ.indels.breakmulti.withOutSV.uniq.vcf.gz

# Normalize the genotype in GT tag
gzip -dc 129S1_SvImJ.indels.breakmulti.withOutSV.uniq.vcf.gz | perl -ane 'if(/^#/){print}else{@a=split ":",$F[-1];$a[0]=~s/\./0/;$a[0]=~s/\|/\//;@b=split "/",$a[0];if($b[0]>$b[1]){$a[0]="$b[1]/$b[0]"}else{$a[0]="$b[0]/$b[1]"};$F[-1]=join ":",@a; print join "\t", @F;print "\n";}' | bgziptabix 129S1_SvImJ.indels.breakmulti.withOutSV.uniq.normalizeGT.vcf.gz

### SNPS ###
# Preprocessing baseline VCF file
gzip -dc 129S1_SvImJ.snps_all.vcf.gz | vcfbreakmulti | bgziptabix 129S1_SvImJ.snps_all.breakmulti.vcf.gz

# Remove insertions and deletions >4bp from baseline
gzip -dc 129S1_SvImJ.snps_all.breakmulti.vcf.gz | perl -ane 'if(/^#/){print}else{if(length($F[3])==1 && length($F[4])==1){print}elsif(length($F[3])==1 && length($F[4])<=5){print}elsif(length($F[3])<=5 && length($F[4])==1){print}}' | bgziptabix 129S1_SvImJ.snps_all.breakmulti.withOutSV.vcf.gz

# Retain only one record for heterozygous alternative
gzip -dc 129S1_SvImJ.snps_all.breakmulti.withOutSV.vcf.gz | perl -ane 'BEGIN{%a=();}{if(/^#/){print}elsif(not defined $a{"$F[0]-$F[1]"}){print;$a{"$F[0]-$F[1]"}=1;}}' | bgziptabix 129S1_SvImJ.snps_all.breakmulti.withOutSV.uniq.vcf.gz

# Normalize the genotype in GT tag
gzip -dc 129S1_SvImJ.snps_all.breakmulti.withOutSV.uniq.vcf.gz | perl -ane 'if(/^#/){print}else{@a=split ":",$F[-1];$a[0]=~s/\./0/;$a[0]=~s/\|/\//;@b=split "/",$a[0];if($b[0]>$b[1]){$a[0]="$b[1]/$b[0]"}else{$a[0]="$b[0]/$b[1]"};$F[-1]=join ":",@a; print join "\t", @F;print "\n";}' | bgziptabix 129S1_SvImJ.snps_all.breakmulti.withOutSV.uniq.normalizeGT.vcf.gz

### BENCHMARKING ###

# Evaluating results for indel variant calls based on provided ground truth
rtg vcfeval -t GRCm38_68.18-19.sdf -b mgp.v5.merged.indels.dbSNP142.normed.breakmulti.inbed.withOutSV.uniq.normalizeGT.vcf.gz -c ../mouse_1819/mg001.18-19.sorted.vcf.gz -o 1819IndelBench --sample="129S1_SvImJ"

# Evaluating results for SNP variant calls based on provided ground-truth
rtg vcfeval -t GRCm38_68.18-19.sdf -b mgp.v5.merged.snps_all.dbSNP142.breakmulti.withOutSV.uniq.normalizeGT.vcf.gz -c ../mouse_1819/mg001.18-19.sorted.vcf.gz -o 1819SNPBench --sample="129S1_SvImJ"
